---
title: "RAGなしで始めるナレッジグラフQA——コンテナで再現する比較検証"
emoji: "🧠"
type: "tech"
topics: ["ナレッジグラフ", "Neo4j", "Cypher", "SPARQL", "SHACL"]
published: false
---

# RAG なしで始めるナレッジグラフ QA——コンテナで再現する比較検証

**ねらい**
RAG（ベクタ検索）を使わず、**ナレッジグラフだけで論理的に答える**最小構成を、Docker だけで動かして確認する。差分・否定・経路・カウントなど、**RAG が失敗しやすい問い**で、**KG（Cypher/SPARQL）が正確**に答えられることを手元で再現する。

---

## 重要な注釈：RAG と KG は対立ではなく補完関係

本記事のタイトルは「RAG なし」ですが、これは「RAG を否定する」という意味ではありません。むしろ、**KG と RAG の役割分担を理解するための比較実験** です。

実務では、KG と RAG は併用されます：

- **RAG の役割**：大量の非構造化テキスト（ドキュメント、記事、ログ）から関連情報を素早く検索し、文脈を提供する
- **KG の役割**：構造化された知識（エンティティ・関係・ルール）から論理的に推論し、正確な回答を導く

本記事では、**KG が得意とする領域を明確にするために、敢えて KG 単独での動作を検証** しています。実装では RAG（Qdrant）も起動していますが、意図的に LLM を使わずに、**データストアの本質的な特性の違い** を浮き彫りにしています。

### 設計的な重要なポイント：なぜ LLM を使わないのか

この実験では、意図的に LLM を省いています。パイプラインは以下の通り：

- **KG**: 質問 → Cypher（手書き） → グラフ実行 → 回答
- **RAG**: 質問 → ベクトル埋め込み → テキスト検索 → キーワード抽出 → 回答

現実のシステムでは、RAG の後ろに LLM（ChatGPT など）がついて自然言語で回答を生成します。しかし、その LLM でも **データストアの根本的な特性（テキスト検索の曖昧性）は超えられません**。詳しくは「RAGを超える知識統合」の[5つの意味問合せ型](https://zenn.dev/knowledge_graph/articles/beyond-rag-knowledge-graph#rag%E3%81%8C%E8%8B%A6%E6%89%8B%E3%83%BBkg%E3%81%8C%E5%BE%97%E6%84%8F%E3%81%AA%E3%80%8C%E6%84%8F%E5%91%B3%E5%95%8F%E5%90%88%E3%81%9B%E3%81%AE5%E5%9E%8B%E3%80%8D)をご参照ください。

### エンジニアリング・リソースの長期的視点

RAG は「プロンプト調整」「リランキング」などで精度を上げられますが、継続的な調整が必要です。一方、KG は構造確定後は安定します：

| 観点 | RAG | KG |
|------|-----|-----|
| **embedding モデル進化時** | 全データ再処理・再チューニング | 影響なし |
| **LLM 変更時** | プロンプト再調整必須 | 影響なし |
| **スケーリング（規模増大時）** | ベクトル検索の計算コスト爆増 | Cypher クエリで線形時間実行 |

**大規模運用での実例**：Wikidata（8,800万エンティティ）のような規模では、RAG のベクトル検索は実用的でなく、KG は高速に応答可能です。

**実務的な結論**：初期段階では RAG が低コストで有効。しかし、**長期的・大規模運用を視野に入れると、KG への投資が ROI が高い**。理想は「論理的クエリが必要なら KG、テキスト探索が必要なら RAG を補助」という役割分担です。

---

## 1. 何を用意するか（ローカルのみ）

- macOS（または Linux/WSL2）
- **Docker / Docker Compose v2**
- `curl`（動作確認）
- 使うもの：
  - **Neo4j 5**（Property Graph, Cypher）
  - **Qdrant**（RAG ベースライン用のベクタ DB：比較対象。RAG 自体は“失敗例”として参照）

> この記事は **RAG を“使わない”実装が主役**ですが、比較のため最小の RAG ベースラインも同時起動します。

---

## 2. 実験環境の構成

本実験は Docker コンテナで動作し、以下が起動します：

- **Neo4j 5** — ナレッジグラフ（Property Graph）
- **Qdrant** — ベクトル DB（RAG のベースライン）
- **FastAPI** — 比較用 API

詳細なセットアップ手順、試験データセット（5 項目版・50 項目版）、試験問いについては、GitHub の実装ガイドを参照してください。

> **→ [実装ガイド: experiments/kg-no-rag/README.md](https://github.com/DevRev-JP/tech-blog/tree/main/experiments/kg-no-rag)**

このガイドには以下が含まれます：

- グラフ構造と試験データの詳細説明
- 5つの試験問い（集合・差分・経路・否定・交差）
- クイックスタートコマンド
- API エンドポイントの使い方
- 50項目データセットによるスケール依存性の実証

---

## 3. 実行結果の概要

ローカルで実行すると、以下の結果が得られます。

### 5 項目版

```json
{
  "summary": {
    "kg_correct": 5,
    "kg_total": 5,
    "rag_correct": 2,
    "rag_total": 5
  }
}
```

**解釈**: KG は全問正解。RAG は集合・交差のみ正解。

### 50 項目版

```json
{
  "summary": {
    "kg_correct": 5,
    "kg_total": 5,
    "rag_correct": 0,
    "rag_total": 5
  }
}
```

**解釈**: KG は相変わらず全問正解。RAG は全滅（ノイズが増えると精度が急落）。

---

## 4. 結果の解釈

### なぜこの差が出たのか

| 質問型 | KG | RAG(5項目) | RAG(50項目) | 理由 |
|------|----|----|----|----|
| **Q1-集合** | ✅ | ✅ | ❌ | 集合操作は明確だが、ノイズが多いと埋もれる |
| **Q2-差分** | ✅ | ❌ | ❌ | 差分操作はベクトル検索に不向き |
| **Q3-経路** | ✅ | ❌ | ❌ | グラフの多段階経路をベクトル検索では追跡不可 |
| **Q4-否定** | ✅ | ❌ | ❌ | 論理的否定条件が曖昧なテキストでは実現困難 |
| **Q5-交差** | ✅ | ✅ | ❌ | 共通要素は明確だが、スケールで失敗 |

### KG の強み

1. **スケール不変性** — データが 5 件でも 50 件でも、Cypher クエリの結果は同じ
2. **論理厳密性** — 集合、差分、否定、経路追跡を正確に実行
3. **構造理解** — ドメイン知識をグラフ構造として記述すれば、複雑な関係も明確に表現可能

### RAG の限界

1. **スケール依存性** — データが増えるとベクトル検索のノイズが増加
2. **操作的な問い** — 差分、否定、カウント、経路追跡は得意でない
3. **曖昧性** — テキストが増えるほど意図を正確に拾いづらくなる

---

## 6. さらに学ぶために

### 理論的背景

本記事で実装した内容の理論的背景やアーキテクチャ的な位置づけについては、以下の記事をご覧ください：

- **「RAGを超える知識統合──ナレッジグラフで"つながる推論"を実現する」**
  - RAG と KG の本質的な違い
  - GraphRAG と KG の関係性
  - エンタープライズ知識グラフの戦略的な役割

### 技術資料

- **Neo4j ドキュメント**: https://neo4j.com/docs/
- **Cypher 解説**: https://neo4j.com/docs/cypher-manual/
- **セマンティック Web との統合**: SPARQL、RDF、OWL
- **スケールアップ**: Wikidata、DBpedia への連携

---

※本記事は AI を活用して執筆しています。
