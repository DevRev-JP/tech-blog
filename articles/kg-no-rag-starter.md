---
title: "RAGなしで始めるナレッジグラフQA——コンテナで再現する比較検証"
emoji: "🧠"
type: "tech"
topics: ["ナレッジグラフ", "Neo4j", "Cypher", "SPARQL", "SHACL"]
published: true
---

# RAG なしで始めるナレッジグラフ QA——コンテナで再現する比較検証

**ねらい**
RAG（ベクタ検索）を使わず、**ナレッジグラフだけで論理的に答える**最小構成を、Docker だけで動かして確認する。差分・否定・経路・カウントなど、**RAG が失敗しやすい問い**で、**KG（Cypher/SPARQL）が正確**に答えられることを手元で再現する。

---

## 重要な注釈：RAG と KG は対立ではなく補完関係

本記事のタイトルは「RAG なし」ですが、これは「RAG を否定する」という意味ではありません。むしろ、**KG と RAG の役割分担を理解するための比較実験** です。

実務では、KG と RAG は併用されます：

- **RAG の役割**：大量の非構造化テキスト（ドキュメント、記事、ログ）から関連情報を素早く検索し、文脈を提供する
- **KG の役割**：構造化された知識（エンティティ・関係・ルール）から論理的に推論し、正確な回答を導く

本記事では、**KG が得意とする領域を明確にするために、敢えて KG 単独での動作を検証** しています。実装では RAG（Qdrant）も起動していますが、意図的に LLM を使わずに、**データストアの本質的な特性の違い** を浮き彫りにしています。

### 設計的な重要なポイント：なぜ LLM を使わないのか

この実験では、意図的に LLM を省いています。パイプラインは以下の通り：

- **KG**: 質問 → Cypher（手書き） → グラフ実行 → 回答
- **RAG**: 質問 → ベクトル埋め込み → テキスト検索 → キーワード抽出 → 回答

現実のシステムでは、RAG の後ろに LLM（ChatGPT など）がついて自然言語で回答を生成します。しかし、その LLM でも **データストアの根本的な特性（テキスト検索の曖昧性）は超えられません**。詳しくは「RAGを超える知識統合」の[5つの意味問合せ型](https://zenn.dev/knowledge_graph/articles/beyond-rag-knowledge-graph#rag%E3%81%8C%E8%8B%A6%E6%89%8B%E3%83%BBkg%E3%81%8C%E5%BE%97%E6%84%8F%E3%81%AA%E3%80%8C%E6%84%8F%E5%91%B3%E5%95%8F%E5%90%88%E3%81%9B%E3%81%AE5%E5%9E%8B%E3%80%8D)を参照してください。

### エンジニアリング・リソースの長期的視点

RAG は「プロンプト調整」「リランキング」などで精度を上げられますが、継続的な調整が必要です。一方、KG は構造確定後は安定します：

| 観点 | RAG | KG |
|------|-----|-----|
| **embedding モデル進化時** | 全データ再処理・再チューニング | 影響なし |
| **LLM 変更時** | プロンプト再調整必須 | 影響なし |
| **スケーリング（規模増大時）** | ベクトル検索の計算コスト爆増 | Cypher クエリで線形時間実行 |

**大規模運用での実例**：Wikidata（8,800万エンティティ）のような規模では、RAG のベクトル検索は実用的でなく、KG は高速に応答可能です。

**実務的な結論**：初期段階では RAG が低コストで有効。しかし、**長期的・大規模運用を視野に入れると、KG への投資が ROI が高い**。理想は「論理的クエリが必要なら KG、テキスト探索が必要なら RAG を補助」という役割分担です。

---

## 1. 何を用意するか（ローカルのみ）

- macOS（または Linux/WSL2）
- **Docker / Docker Compose v2**
- `curl`（動作確認）
- 使うもの：
  - **Neo4j 5**（Property Graph, Cypher）
  - **Qdrant**（RAG ベースライン用のベクタ DB：比較対象。RAG 自体は“失敗例”として参照）

> この記事は **RAG を“使わない”実装が主役**ですが、比較のため最小の RAG ベースラインも同時起動します。

---

## 2. 実験環境の構成

本実験は Docker コンテナで動作し、以下が起動します：

- **Neo4j 5** — ナレッジグラフ（Property Graph）
- **Qdrant** — ベクトル DB（RAG のベースライン）
- **FastAPI** — 比較用 API

詳細なセットアップ手順、試験データセット（5 項目版・50 項目版）、試験問いについては、GitHub の実装ガイドを参照してください。

> **→ [実装ガイド: experiments/kg-no-rag/README.md](https://github.com/DevRev-JP/tech-blog/tree/main/experiments/kg-no-rag)**

このガイドには以下が含まれます：

- グラフ構造と試験データの詳細説明
- 5つの試験問い（集合・差分・経路・否定・交差）
- クイックスタートコマンド
- API エンドポイントの使い方
- 50項目データセットによるスケール依存性の実証

---

## 3. 5つの意味問合せ型——KG が得意、RAG が失敗しやすい質問パターン

本実験で検証する5つの質問タイプを具体例で示します。

### Q1-集合（Union） — 「AまたはB に該当するものは？」

```
Q: "ソフトウェアエンジニアまたはデータサイエンティストは誰ですか？"

KG (Cypher):
  MATCH (p:Person)-[:hasRole]->(r:Role)
  WHERE r.name IN ['SoftwareEngineer', 'DataScientist']
  RETURN p.name

RAG:
  → ベクトル検索で "エンジニア" "データサイエンティスト" を検索
  → ノイズが多い場合、関連ドキュメントが多すぎて曖昧
```

### Q2-差分（Set Difference） — 「A に属するが B には属さない者は？」

```
Q: "プロジェクトXに参加しているがプロジェクトYには参加していない人は？"

KG (Cypher):
  MATCH (p:Person)-[:participates]->(px:Project {name: 'X'})
  WHERE NOT EXISTS { (p)-[:participates]->(:Project {name: 'Y'}) }
  RETURN p.name

RAG:
  → 「プロジェクトX」と「プロジェクトY」の差を推論できない
  → テキスト検索では否定条件を正確に表現不可
```

### Q3-経路（Path Traversal） — 「A から B へのつながりは？」

```
Q: "太郎がプロジェクトXを通じて、どの組織につながっているか？"

KG (Cypher):
  MATCH path = (p:Person {name: '太郎'})-[:participates]->(:Project {name: 'X'})-[:belongsTo]->(org:Organization)
  RETURN org.name, path

RAG:
  → 多段階のグラフ構造を追跡できない
  → テキスト検索は "点" 単位であり、"経路" を辿れない
```

### Q4-否定（Negation） — 「A ではない条件を満たすのは？」

```
Q: "東京オフィスに配属されていない従業員は？"

KG (Cypher):
  MATCH (emp:Employee)
  WHERE NOT EXISTS { (emp)-[:assignedTo]->(:Office {location: 'Tokyo'}) }
  RETURN emp.name

RAG:
  → 「否定」という論理演算子をテキストから推論困難
  → ベクトル検索は類似度で判定するため、"ない" という条件が曖昧
```

### Q5-交差（Intersection） — 「A かつ B の両方に属する者は？」

```
Q: "プロジェクトXにも参加し、かつ管理職でもある人は？"

KG (Cypher):
  MATCH (p:Person)-[:participates]->(:Project {name: 'X'})
  MATCH (p)-[:hasRole]->(r:Role {type: 'Manager'})
  RETURN p.name

RAG:
  → 複数条件の交差をベクトル検索では不正確
  → スケール増加時にノイズが増えると精度が急落
```

### 結果の見え方

| 質問型 | KG | RAG(小規模) | RAG(大規模) | 理由 |
|------|----|----|----|----|
| Q1-集合 | ✅ 正確 | ✅ 成功 | ❌ ノイズで失敗 | OR は明確だが、ノイズに弱い |
| Q2-差分 | ✅ 正確 | ✅ 成功 | ❌ 失敗 | 小規模では偶発的に成功。スケール増で失敗 |
| Q3-経路 | ✅ 正確 | ❌ 失敗 | ❌ 失敗 | 多段階経路をベクトル検索で追跡不可 |
| Q4-否定 | ✅ 正確 | ❌ 失敗 | ❌ 失敗 | 論理的否定が曖昧 |
| Q5-交差 | ✅ 正確 | ✅ 成功 | ❌ 失敗 | 複数条件の厳密なAND が難しい |

---

## 4. 実行結果の概要

ローカルで実行すると、以下の結果が得られます。

### 5 項目版

```json
{
  "summary": {
    "kg_correct": 5,
    "kg_total": 5,
    "rag_correct": 2,
    "rag_total": 5
  }
}
```

**解釈**: KG は全問正解。RAG は集合・交差のみ正解。

※RAG の結果は実行ごとに変動する可能性があります（おおむね 2～3/5 の範囲）

### 50 項目版

```json
{
  "summary": {
    "kg_correct": 5,
    "kg_total": 5,
    "rag_correct": 1,
    "rag_total": 5
  }
}
```

**解釈**: KG は相変わらず全問正解。RAG は大幅に精度低下（ノイズが増えると精度が急落）。

※RAG の結果は実行ごとに変動する可能性があります（おおむね 0～1/5 の範囲。ベクトル空間における類似度計算の不確定性による）

---

## 5. 結果の解釈

### なぜこの差が出たのか

| 質問型 | KG | RAG(5項目) | RAG(50項目) | 理由 |
|------|----|----|----|----|
| **Q1-集合** | ✅ | ✅ | ❌ | 集合操作は明確だが、ノイズが多いと埋もれる |
| **Q2-差分** | ✅ | ✅ | ❌ | 小規模では偶発的に成功。スケール増加で失敗 |
| **Q3-経路** | ✅ | ❌ | ❌ | グラフの多段階経路をベクトル検索では追跡不可 |
| **Q4-否定** | ✅ | ❌ | ❌ | 論理的否定条件が曖昧なテキストでは実現困難 |
| **Q5-交差** | ✅ | ✅ | ❌ | 共通要素は明確だが、スケールで失敗 |

### KG の強み

1. **スケール不変性** — データが 5 件でも 50 件でも、Cypher クエリの結果は同じ
2. **論理厳密性** — 集合、差分、否定、経路追跡を正確に実行
3. **構造理解** — ドメイン知識をグラフ構造として記述すれば、複雑な関係も明確に表現可能

### RAG の限界

1. **スケール依存性** — データが増えるとベクトル検索のノイズが増加
2. **操作的な問い** — 差分、否定、カウント、経路追跡は得意でない
3. **曖昧性** — テキストが増えるほど意図を正確に拾いづらくなる

---

## 6. さらに学ぶために

### 理論的背景

本記事で実装した内容の理論的背景やアーキテクチャ的な位置づけについては、以下の記事をご覧ください：

- **[「RAGを超える知識統合──ナレッジグラフで"つながる推論"を実現する」](https://zenn.dev/knowledge_graph/articles/beyond-rag-knowledge-graph)**
  - RAG と KG の本質的な違い
  - GraphRAG と KG の関係性
  - エンタープライズ知識グラフの戦略的な役割

### 技術資料

- **Neo4j ドキュメント**: https://neo4j.com/docs/
- **Cypher 解説**: https://neo4j.com/docs/cypher-manual/
- **セマンティック Web との統合**: SPARQL、RDF、OWL
- **スケールアップ**: Wikidata、DBpedia への連携

---

## 更新履歴

- **2025-10-24** — 初版公開。実行結果セクションを更新し、RAG の結果がベクトル埋め込みの不確定性により実行ごとに変動する可能性を明記。50項目版の代表値を 0/5 から 1/5 に修正し、実際の測定範囲（0～1/5）を記載

※本記事は AI を活用して執筆しています。
