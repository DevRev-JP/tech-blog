---
title: "RAGなしで始めるナレッジグラフQA——コンテナで再現する比較検証"
emoji: "🧠"
type: "tech"
topics: ["ナレッジグラフ", "Neo4j", "Cypher", "SPARQL", "SHACL"]
published: false
---

# RAG なしで始めるナレッジグラフ QA——コンテナで再現する比較検証

**ねらい**
RAG（ベクタ検索）を使わず、**ナレッジグラフだけで論理的に答える**最小構成を、Docker だけで動かして確認する。差分・否定・経路・カウントなど、**RAG が失敗しやすい問い**で、**KG（Cypher/SPARQL）が正確**に答えられることを手元で再現する。

---

## 重要な注釈：RAG と KG は対立ではなく補完関係

本記事のタイトルは「RAG なし」ですが、これは「RAG を否定する」という意味ではありません。むしろ、**KG と RAG の役割分担を理解するための比較実験** です。

実務では、KG と RAG は併用されます：

- **RAG の役割**：大量の非構造化テキスト（ドキュメント、記事、ログ）から関連情報を素早く検索し、文脈を提供する
- **KG の役割**：構造化された知識（エンティティ・関係・ルール）から論理的に推論し、正確な回答を導く

本記事では、**KG が得意とする領域を明確にするために、敢えて KG 単独での動作を検証** しています。実装では RAG（Qdrant）も起動していますが、意図的に LLM を使わずに、**データストアの本質的な特性の違い** を浮き彫りにしています。

### 設計的な重要なポイント：なぜ LLM を使わないのか

この実験では、意図的に LLM を省いています。パイプラインは以下の通り：

- **KG**: 質問 → Cypher（手書き） → グラフ実行 → 回答
- **RAG**: 質問 → ベクトル埋め込み → テキスト検索 → キーワード抽出 → 回答

現実のシステムでは、RAG の後ろに LLM（ChatGPT など）がついて自然言語で回答を生成します。しかし、その LLM でも以下は改善できません：

1. **差分操作** — 曖昧なテキスト検索結果から正確な差分は生成困難
2. **経路追跡** — グラフの多段階関係をテキスト検索では見落とす
3. **論理的否定** — 「持たない」条件はテキスト検索結果から推論困難

**結論**：LLM を追加しても、**データストアの根本的な限界は超えられません**。構造化知識（KG）が必要な理由はここにあります。

現実のシステムでは、「ユーザーの問いが KG で答えられるか、RAG で探索すべきか」を自動判定し、適切に組み合わせることが重要です。

---

## 1. 何を用意するか（ローカルのみ）

- macOS（または Linux/WSL2）
- **Docker / Docker Compose v2**
- `curl`（動作確認）
- 使うもの：
  - **Neo4j 5**（Property Graph, Cypher）
  - **Qdrant**（RAG ベースライン用のベクタ DB：比較対象。RAG 自体は“失敗例”として参照）

> この記事は **RAG を“使わない”実装が主役**ですが、比較のため最小の RAG ベースラインも同時起動します。

---

## 2. 実験環境の構成

本実験は Docker コンテナで動作し、以下が起動します：

- **Neo4j 5** — ナレッジグラフ（Property Graph）
- **Qdrant** — ベクトル DB（RAG のベースライン）
- **FastAPI** — 比較用 API

詳細なセットアップ手順、試験データセット（5 項目版・50 項目版）、試験問いについては、GitHub の実装ガイドを参照してください。

> **→ [実装ガイド: experiments/kg-no-rag/README.md](https://github.com/DevRev-JP/tech-blog/tree/main/experiments/kg-no-rag)**

このガイドには以下が含まれます：

- グラフ構造と試験データの詳細説明
- 5つの試験問い（集合・差分・経路・否定・交差）
- クイックスタートコマンド
- API エンドポイントの使い方
- 50項目データセットによるスケール依存性の実証

---

## 3. 実行結果の概要

ローカルで実行すると、以下の結果が得られます。

### 5 項目版

```json
{
  "summary": {
    "kg_correct": 5,
    "kg_total": 5,
    "rag_correct": 2,
    "rag_total": 5
  }
}
```

**解釈**: KG は全問正解。RAG は集合・交差のみ正解。

### 50 項目版

```json
{
  "summary": {
    "kg_correct": 5,
    "kg_total": 5,
    "rag_correct": 0,
    "rag_total": 5
  }
}
```

**解釈**: KG は相変わらず全問正解。RAG は全滅（ノイズが増えると精度が急落）。

---

## 4. 結果の解釈

### なぜこの差が出たのか

| 質問型 | KG | RAG(5項目) | RAG(50項目) | 理由 |
|------|----|----|----|----|
| **Q1-集合** | ✅ | ✅ | ❌ | 集合操作は明確だが、ノイズが多いと埋もれる |
| **Q2-差分** | ✅ | ❌ | ❌ | 差分操作はベクトル検索に不向き |
| **Q3-経路** | ✅ | ❌ | ❌ | グラフの多段階経路をベクトル検索では追跡不可 |
| **Q4-否定** | ✅ | ❌ | ❌ | 論理的否定条件が曖昧なテキストでは実現困難 |
| **Q5-交差** | ✅ | ✅ | ❌ | 共通要素は明確だが、スケールで失敗 |

### KG の強み

1. **スケール不変性** — データが 5 件でも 50 件でも、Cypher クエリの結果は同じ
2. **論理厳密性** — 集合、差分、否定、経路追跡を正確に実行
3. **構造理解** — ドメイン知識をグラフ構造として記述すれば、複雑な関係も明確に表現可能

### RAG の限界

1. **スケール依存性** — データが増えるとベクトル検索のノイズが増加
2. **操作的な問い** — 差分、否定、カウント、経路追跡は得意でない
3. **曖昧性** — テキストが増えるほど意図を正確に拾いづらくなる

---

## 6. さらに学ぶために

### 理論的背景

本記事で実装した内容の理論的背景やアーキテクチャ的な位置づけについては、以下の記事をご覧ください：

- **「RAGを超える知識統合──ナレッジグラフで"つながる推論"を実現する」**
  - RAG と KG の本質的な違い
  - GraphRAG と KG の関係性
  - エンタープライズ知識グラフの戦略的な役割

### 技術資料

- **Neo4j ドキュメント**: https://neo4j.com/docs/
- **Cypher 解説**: https://neo4j.com/docs/cypher-manual/
- **セマンティック Web との統合**: SPARQL、RDF、OWL
- **スケールアップ**: Wikidata、DBpedia への連携

---

※本記事は AI を活用して執筆しています。
